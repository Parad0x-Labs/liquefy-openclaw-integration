#!/usr/bin/env python3
"""
liquefy_agents.py
=================
Agent catalog + scaffolding helper for OpenClaw-like runtimes.

Commands:
    list                         List built-in agent templates.
    show <agent_id>              Show one agent template in detail.
    map [--chain <chain_id>]     Show interaction chains between agents.
    scaffold <agent_id>          Generate a runnable local agent workspace.
"""
from __future__ import annotations

import argparse
import json
import os
import stat
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional

from cli_runtime import resolve_repo_root

REPO_ROOT = resolve_repo_root(__file__)
CATALOG_PATH = REPO_ROOT / "tools" / "agents" / "catalog.json"
CLI_SCHEMA_VERSION = "liquefy.agents.cli.v1"


def _utc_now() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def _emit_json(command: str, ok: bool, result: Dict[str, Any]) -> None:
    payload = {
        "schema_version": CLI_SCHEMA_VERSION,
        "tool": "liquefy_agents",
        "command": command,
        "ok": ok,
        "generated_at_utc": _utc_now(),
        "result": result,
    }
    print(json.dumps(payload, indent=2))


def _load_catalog() -> Dict[str, Any]:
    if not CATALOG_PATH.exists():
        raise FileNotFoundError(f"Catalog not found: {CATALOG_PATH}")
    return json.loads(CATALOG_PATH.read_text(encoding="utf-8"))


def _agent_by_id(catalog: Dict[str, Any], agent_id: str) -> Optional[Dict[str, Any]]:
    for agent in catalog.get("agents", []):
        if agent.get("id") == agent_id:
            return agent
    return None


def _chain_by_id(catalog: Dict[str, Any], chain_id: str) -> Optional[Dict[str, Any]]:
    for chain in catalog.get("chains", []):
        if chain.get("id") == chain_id:
            return chain
    return None


def _runtime_command(runtime: str) -> str:
    if runtime == "openclaw":
        return "openclaw run task.md"
    if runtime == "nanoclaw":
        return "nanoclaw run task.md"
    return "python3 agent.py --task task.md"


def _scaffold_files(agent: Dict[str, Any], runtime: str, out_dir: Path, trace_id_prefix: str) -> Dict[str, str]:
    agent_id = str(agent["id"])
    agent_name = str(agent["name"])
    default_policy = str(agent.get("default_policy", ""))
    default_profile = str(agent.get("liquefy_profile", "default"))
    safe_defaults = dict(agent.get("safe_defaults", {}))
    action_mode_default = str(safe_defaults.get("action_mode", "observe_only"))
    require_approval_default = bool(safe_defaults.get("require_approval", False))
    max_actions_per_run_default = int(safe_defaults.get("max_actions_per_run", 50))
    max_actions_per_hour_default = int(safe_defaults.get("max_actions_per_hour", 200))
    quiet_hours_default = str(safe_defaults.get("quiet_hours_utc", ""))
    recipient_allowlist_required_default = bool(safe_defaults.get("recipient_allowlist_required", False))
    allow_external_links_default = bool(safe_defaults.get("allow_external_links", False))
    deny_content_patterns = list(safe_defaults.get("deny_content_patterns", []))
    runtime_cmd = _runtime_command(runtime)
    safe_mode_line = (
        f"- safe action mode: `{action_mode_default}` (approval required={require_approval_default})"
        if safe_defaults else
        "- safe action mode: `observe_only`"
    )
    guardrails_line = (
        f"- guardrails: `max/run={max_actions_per_run_default}`, "
        f"`max/hour={max_actions_per_hour_default}`, quiet=`{quiet_hours_default or 'none'}`"
        if safe_defaults else
        "- guardrails: defaults only"
    )

    readme = f"""# {agent_name}

Generated by `liquefy agents scaffold`.

## Purpose
{agent.get("description", "N/A")}

## Runtime
- runtime: `{runtime}`
- primary command: `{runtime_cmd}`
- policy: `{default_policy or "(use tool default)"}`
{safe_mode_line}
{guardrails_line}

## Inputs
{os.linesep.join(f"- `{i}`" for i in agent.get("inputs", []))}

## Outputs
{os.linesep.join(f"- `{o}`" for o in agent.get("outputs", []))}

## Interaction
- upstream/downstream peers:
{os.linesep.join(f"- `{a}`" for a in agent.get("interacts_with", []))}

## Run
```bash
./run.sh
```
"""

    task_md = f"""# {agent_name} Task

## Objective
Describe what this run should accomplish.

## Input Contract
{os.linesep.join(f"- {i}: <fill>" for i in agent.get("inputs", []))}

## Output Contract
{os.linesep.join(f"- {o}: <expected>" for o in agent.get("outputs", []))}

## Constraints
- no secrets in output artifacts
- keep actions auditable and deterministic where possible
"""

    handoff = {
        "schema": "liquefy.agent.handoff.v1",
        "schema_version": 1,
        "agent_id": agent_id,
        "agent_name": agent_name,
        "inputs": agent.get("inputs", []),
        "outputs": agent.get("outputs", []),
        "interacts_with": agent.get("interacts_with", []),
    }

    env_example = f"""# Generated env for {agent_id}
WORKSPACE=${{WORKSPACE:-$HOME/.openclaw}}
OUT_DIR=${{OUT_DIR:-./vault/{agent_id}}}
TRACE_ID=${{TRACE_ID:-{trace_id_prefix}-{agent_id}}}
RECOMMENDED_POLICY="{default_policy}"  # informational
POLICY=${{POLICY:-}}                   # optional, leave empty for tool default
PACK_PROFILE=${{PACK_PROFILE:-{default_profile}}}
PACK_MODE=${{PACK_MODE:-strict}}
RUNTIME_CMD=${{RUNTIME_CMD:-{runtime_cmd}}}
ACTION_MODE=${{ACTION_MODE:-{action_mode_default}}}             # draft_only | observe_only | active
REQUIRE_APPROVAL=${{REQUIRE_APPROVAL:-{"1" if require_approval_default else "0"}}}
MAX_ACTIONS_PER_RUN=${{MAX_ACTIONS_PER_RUN:-{max_actions_per_run_default}}}
MAX_ACTIONS_PER_HOUR=${{MAX_ACTIONS_PER_HOUR:-{max_actions_per_hour_default}}}
QUIET_HOURS_UTC=${{QUIET_HOURS_UTC:-{quiet_hours_default}}}
RECIPIENT_ALLOWLIST_REQUIRED=${{RECIPIENT_ALLOWLIST_REQUIRED:-{"1" if recipient_allowlist_required_default else "0"}}}
ALLOW_EXTERNAL_LINKS=${{ALLOW_EXTERNAL_LINKS:-{"1" if allow_external_links_default else "0"}}}
ALLOWLIST_FILE=${{ALLOWLIST_FILE:-$PWD/allowlist.txt}}
HUMAN_APPROVAL_TOKEN=${{HUMAN_APPROVAL_TOKEN:-}}   # required for active mode when REQUIRE_APPROVAL=1
PLANNED_ACTIONS=${{PLANNED_ACTIONS:-0}}
"""

    run_sh = f"""#!/usr/bin/env bash
set -euo pipefail

AGENT_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
REPO_ROOT="$(cd "$AGENT_DIR/../.." && pwd)"
cd "$REPO_ROOT"
if [[ -f "$AGENT_DIR/agent.env" ]]; then
  # shellcheck source=/dev/null
  source "$AGENT_DIR/agent.env"
elif [[ -f "$AGENT_DIR/agent.env.example" ]]; then
  # shellcheck source=/dev/null
  source "$AGENT_DIR/agent.env.example"
fi

WORKSPACE="${{WORKSPACE:-$HOME/.openclaw}}"
OUT_DIR="${{OUT_DIR:-./vault/{agent_id}}}"
TRACE_ID="${{TRACE_ID:-{trace_id_prefix}-{agent_id}}}"
POLICY="${{POLICY:-}}"
PACK_PROFILE="${{PACK_PROFILE:-{default_profile}}}"
PACK_MODE="${{PACK_MODE:-strict}}"
RUNTIME_CMD="${{RUNTIME_CMD:-{runtime_cmd}}}"
ACTION_MODE="${{ACTION_MODE:-{action_mode_default}}}"
REQUIRE_APPROVAL="${{REQUIRE_APPROVAL:-{"1" if require_approval_default else "0"}}}"
MAX_ACTIONS_PER_RUN="${{MAX_ACTIONS_PER_RUN:-{max_actions_per_run_default}}}"
MAX_ACTIONS_PER_HOUR="${{MAX_ACTIONS_PER_HOUR:-{max_actions_per_hour_default}}}"
QUIET_HOURS_UTC="${{QUIET_HOURS_UTC:-{quiet_hours_default}}}"
RECIPIENT_ALLOWLIST_REQUIRED="${{RECIPIENT_ALLOWLIST_REQUIRED:-{"1" if recipient_allowlist_required_default else "0"}}}"
ALLOW_EXTERNAL_LINKS="${{ALLOW_EXTERNAL_LINKS:-{"1" if allow_external_links_default else "0"}}}"
ALLOWLIST_FILE="${{ALLOWLIST_FILE:-$PWD/allowlist.txt}}"
HUMAN_APPROVAL_TOKEN="${{HUMAN_APPROVAL_TOKEN:-}}"
PLANNED_ACTIONS="${{PLANNED_ACTIONS:-0}}"

if [[ "$PLANNED_ACTIONS" =~ ^[0-9]+$ ]] && (( PLANNED_ACTIONS > MAX_ACTIONS_PER_RUN )); then
  echo "blocked: planned actions ($PLANNED_ACTIONS) exceed max per run ($MAX_ACTIONS_PER_RUN)" >&2
  exit 41
fi

if [[ "$ACTION_MODE" == "active" ]]; then
  if [[ "$REQUIRE_APPROVAL" == "1" && -z "$HUMAN_APPROVAL_TOKEN" ]]; then
    echo "blocked: active mode requires HUMAN_APPROVAL_TOKEN when REQUIRE_APPROVAL=1" >&2
    exit 42
  fi
  if [[ "$RECIPIENT_ALLOWLIST_REQUIRED" == "1" && ! -s "$ALLOWLIST_FILE" ]]; then
    echo "blocked: allowlist required for active mode, missing $ALLOWLIST_FILE" >&2
    exit 43
  fi
fi

mkdir -p "$OUT_DIR"
if [[ -n "$POLICY" ]]; then
  python3 tools/liquefy_safe_run.py \\
    --workspace "$WORKSPACE" \\
    --cmd "$RUNTIME_CMD" \\
    --policy "$POLICY" \\
    --trace-id "$TRACE_ID" \\
    --heartbeat \\
    --sentinels SOUL.md,HEARTBEAT.md,auth-profiles.json \\
    --json | tee "$OUT_DIR/safe_run_{agent_id}.json"
else
  python3 tools/liquefy_safe_run.py \\
    --workspace "$WORKSPACE" \\
    --cmd "$RUNTIME_CMD" \\
    --trace-id "$TRACE_ID" \\
    --heartbeat \\
    --sentinels SOUL.md,HEARTBEAT.md,auth-profiles.json \\
    --json | tee "$OUT_DIR/safe_run_{agent_id}.json"
fi

python3 tools/liquefy_openclaw.py \\
  --workspace "$WORKSPACE" \\
  --out "$OUT_DIR" \\
  --apply \\
  --trace-id "$TRACE_ID" \\
  --verify-mode full \\
  --profile "$PACK_PROFILE" \\
  --mode "$PACK_MODE" \\
  --hash-cache \\
  --json | tee "$OUT_DIR/pack_{agent_id}.json"

echo "done: agent={agent_id} trace_id=$TRACE_ID out=$OUT_DIR"
"""

    guardrails = {
        "schema": "liquefy.agent.guardrails.v1",
        "schema_version": 1,
        "agent_id": agent_id,
        "action_mode_default": action_mode_default,
        "require_approval_default": require_approval_default,
        "max_actions_per_run_default": max_actions_per_run_default,
        "max_actions_per_hour_default": max_actions_per_hour_default,
        "quiet_hours_utc_default": quiet_hours_default,
        "recipient_allowlist_required_default": recipient_allowlist_required_default,
        "allow_external_links_default": allow_external_links_default,
        "deny_content_patterns": deny_content_patterns,
        "notes": "Set ACTION_MODE=active only with explicit human approval and allowlist controls."
    }

    files = {
        "README.md": readme,
        "task.md": task_md,
        "handoff_contract.json": json.dumps(handoff, indent=2) + "\n",
        "guardrails.json": json.dumps(guardrails, indent=2) + "\n",
        "agent.env.example": env_example,
        "run.sh": run_sh,
    }
    return files


def cmd_list(args: argparse.Namespace) -> int:
    catalog = _load_catalog()
    agents = catalog.get("agents", [])
    rows = [
        {
            "id": a.get("id"),
            "name": a.get("name"),
            "category": a.get("category"),
            "risk": a.get("risk"),
            "profile": a.get("liquefy_profile"),
            "action_mode": (a.get("safe_defaults") or {}).get("action_mode", "observe_only"),
        }
        for a in agents
    ]
    if args.json:
        _emit_json("list", True, {"count": len(rows), "agents": rows})
        return 0

    print(f"Liquefy Agent Catalog ({len(rows)} templates)")
    for row in rows:
        print(
            f"- {row['id']:<28} {row['name']:<28} "
            f"[{row['category']}/{row['risk']}] profile={row['profile']} mode={row['action_mode']}"
        )
    return 0


def cmd_show(args: argparse.Namespace) -> int:
    catalog = _load_catalog()
    agent = _agent_by_id(catalog, args.agent_id)
    if not agent:
        if args.json:
            _emit_json("show", False, {"error": f"Unknown agent_id: {args.agent_id}"})
        else:
            print(f"ERROR: Unknown agent_id: {args.agent_id}", file=sys.stderr)
        return 1

    if args.json:
        _emit_json("show", True, {"agent": agent})
        return 0

    print(f"{agent['name']} ({agent['id']})")
    print(f"category={agent.get('category')} risk={agent.get('risk')}")
    print(f"profile={agent.get('liquefy_profile')} policy={agent.get('default_policy')}")
    print(f"description: {agent.get('description')}")
    print("inputs:")
    for i in agent.get("inputs", []):
        print(f"- {i}")
    print("outputs:")
    for o in agent.get("outputs", []):
        print(f"- {o}")
    print("interacts_with:")
    for w in agent.get("interacts_with", []):
        print(f"- {w}")
    safe_defaults = agent.get("safe_defaults", {})
    if safe_defaults:
        print("safe_defaults:")
        for k, v in safe_defaults.items():
            print(f"- {k}: {v}")
    return 0


def cmd_map(args: argparse.Namespace) -> int:
    catalog = _load_catalog()
    chains = catalog.get("chains", [])
    if args.chain:
        chain = _chain_by_id(catalog, args.chain)
        if not chain:
            if args.json:
                _emit_json("map", False, {"error": f"Unknown chain: {args.chain}"})
            else:
                print(f"ERROR: Unknown chain: {args.chain}", file=sys.stderr)
            return 1
        chains = [chain]

    if args.json:
        _emit_json("map", True, {"chains": chains})
        return 0

    for chain in chains:
        print(f"{chain['name']} ({chain['id']})")
        print(f"  {chain.get('description', '')}")
        print(f"  flow: {' -> '.join(chain.get('sequence', []))}")
    return 0


def cmd_scaffold(args: argparse.Namespace) -> int:
    catalog = _load_catalog()
    agent = _agent_by_id(catalog, args.agent_id)
    if not agent:
        if args.json:
            _emit_json("scaffold", False, {"error": f"Unknown agent_id: {args.agent_id}"})
        else:
            print(f"ERROR: Unknown agent_id: {args.agent_id}", file=sys.stderr)
        return 1

    runtime = args.runtime
    trace_id_prefix = args.trace_id_prefix
    agent_dir_name = args.name or str(agent["id"])
    out_root = Path(args.out).expanduser().resolve()
    out_dir = out_root / agent_dir_name
    out_dir.mkdir(parents=True, exist_ok=True)

    files = _scaffold_files(agent, runtime=runtime, out_dir=out_dir, trace_id_prefix=trace_id_prefix)
    written: List[str] = []
    for rel, content in files.items():
        fpath = out_dir / rel
        fpath.parent.mkdir(parents=True, exist_ok=True)
        fpath.write_text(content, encoding="utf-8")
        written.append(str(fpath))

    run_path = out_dir / "run.sh"
    run_path.chmod(run_path.stat().st_mode | stat.S_IXUSR)

    if args.json:
        _emit_json(
            "scaffold",
            True,
            {
                "agent_id": agent["id"],
                "runtime": runtime,
                "out_dir": str(out_dir),
                "written_files": written,
            },
        )
        return 0

    print(f"scaffolded {agent['id']} -> {out_dir}")
    print("files:")
    for w in written:
        print(f"- {w}")
    print("next:")
    print(f"1) cp {out_dir / 'agent.env.example'} {out_dir / 'agent.env'}  # optional local override")
    print(f"2) edit {out_dir / 'task.md'}")
    print(f"3) {out_dir / 'run.sh'}")
    return 0


def build_parser() -> argparse.ArgumentParser:
    ap = argparse.ArgumentParser(prog="liquefy-agents", description="Liquefy agent catalog and scaffolding")
    sub = ap.add_subparsers(dest="subcmd", required=True)

    p_list = sub.add_parser("list", help="List available agent templates")
    p_list.add_argument("--json", action="store_true")
    p_list.set_defaults(fn=cmd_list)

    p_show = sub.add_parser("show", help="Show details for one agent template")
    p_show.add_argument("agent_id")
    p_show.add_argument("--json", action="store_true")
    p_show.set_defaults(fn=cmd_show)

    p_map = sub.add_parser("map", help="Show built-in interaction chains")
    p_map.add_argument("--chain", help="Specific chain id to print")
    p_map.add_argument("--json", action="store_true")
    p_map.set_defaults(fn=cmd_map)

    p_scaf = sub.add_parser("scaffold", help="Generate runnable local agent workspace")
    p_scaf.add_argument("agent_id")
    p_scaf.add_argument("--out", default=str(REPO_ROOT / "agents"))
    p_scaf.add_argument("--name", help="Directory name override")
    p_scaf.add_argument("--runtime", choices=["openclaw", "nanoclaw", "generic"], default="openclaw")
    p_scaf.add_argument("--trace-id-prefix", default="agent")
    p_scaf.add_argument("--json", action="store_true")
    p_scaf.set_defaults(fn=cmd_scaffold)

    return ap


def main() -> int:
    parser = build_parser()
    args = parser.parse_args()
    return int(args.fn(args))


if __name__ == "__main__":
    raise SystemExit(main())
